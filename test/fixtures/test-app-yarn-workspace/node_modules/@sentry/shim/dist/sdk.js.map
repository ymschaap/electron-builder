{"version":3,"file":"sdk.js","sourceRoot":"","sources":["../src/sdk.ts"],"names":[],"mappings":"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","sourcesContent":["import { getGlobalRegistry } from './global';\nimport { Breadcrumb, SentryEvent, User } from './models';\nimport { API_VERSION, Shim } from './shim';\n\n/** Default callback used for catching async errors. */\nfunction logError(e?: any): void {\n  if (e) {\n    console.error(e);\n  }\n}\n\n/**\n * Internal helper function to call a method on the top client if it exists.\n *\n * @param method The method to call on the client/frontend.\n * @param args Arguments to pass to the client/fontend.\n */\nfunction invokeClient(method: string, ...args: any[]): void {\n  const top = getOrCreateShim().getStackTop();\n  if (top && top.client && top.client[method]) {\n    top.client[method](...args, top.scope);\n  }\n}\n\n/**\n * Internal helper function to call an async method on the top client if it\n * exists.\n *\n * @param method The method to call on the client/frontend.\n * @param callback A callback called with the error or success return value.\n * @param args Arguments to pass to the client/fontend.\n */\nfunction invokeClientAsync<T>(\n  method: string,\n  callback: (error?: any, value?: T) => void,\n  ...args: any[]\n): void {\n  const top = getOrCreateShim().getStackTop();\n  if (top && top.client && top.client[method]) {\n    top.client[method](...args, top.scope)\n      .then((value: T) => {\n        callback(undefined, value);\n      })\n      .catch((err: any) => {\n        callback(err);\n      });\n  }\n}\n\n/**\n * Returns the latest shim instance.\n *\n * If a shim is already registered in the global registry but this module\n * contains a more recent version, it replaces the registered version.\n * Otherwise, the currently registered shim will be returned.\n */\nfunction getOrCreateShim(): Shim {\n  const registry = getGlobalRegistry();\n\n  if (!registry.shim || registry.shim.isOlderThan(API_VERSION)) {\n    registry.shim = new Shim();\n  }\n\n  return registry.shim;\n}\n\n/**\n * Create a new scope to store context information.\n *\n * The scope will be layered on top of the current one. It is isolated, i.e. all\n * breadcrumbs and context information added to this scope will be removed once\n * the scope ends. Be sure to always remove this scope with {@link popScope}\n * when the operation finishes or throws.\n */\nexport function pushScope(client?: any): void {\n  getOrCreateShim().pushScope(client);\n}\n\n/**\n * Removes a previously pushed scope from the stack.\n *\n * This restores the state before the scope was pushed. All breadcrumbs and\n * context information added since the last call to {@link pushScope} are\n * discarded.\n */\nexport function popScope(): void {\n  getOrCreateShim().popScope();\n}\n\n/**\n * Creates a new scope and executes the given operation within. The scope is\n * automatically removed once the operation finishes or throws.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope();\n *     callback();\n *     popScope();\n *\n * @param callback The operation to execute.\n */\nexport function withScope(callback: () => void): void;\n\n/**\n * Creates a new scope with a custom client instance and executes the given\n * operation within. The scope is automatically removed once the operation\n * finishes or throws.\n *\n * The client can be configured with different options than the enclosing scope,\n * such as a different DSN or other callbacks.\n *\n * This is essentially a convenience function for:\n *\n *     pushScope(client);\n *     callback();\n *     popScope();\n *\n * @param client A client to use within the scope.\n * @param callback The operation to execute.\n */\nexport function withScope(client: any, callback: () => void): void;\n\nexport function withScope(arg1: any, arg2?: any): void {\n  getOrCreateShim().withScope(arg1, arg2);\n}\n\n/** Clears the current scope and resets it to the initalScope. */\nexport function clearScope(): void {\n  getOrCreateShim().clearScope();\n}\n\n/** Returns the current client, if any. */\nexport function getCurrentClient(): any | undefined {\n  return getOrCreateShim().getCurrentClient();\n}\n\n/**\n * This binds the given client to the current scope.\n * @param client An SDK client (frontend) instance.\n */\nexport function bindClient(client: any): void {\n  const shim = getOrCreateShim();\n  const top = shim.getStackTop();\n  top.client = client;\n  top.scope = shim.getInitialScope(client);\n}\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception An exception-like object.\n * @param callback A callback that is invoked when the exception has been sent.\n */\nexport function captureException(\n  exception: any,\n  callback: (error?: any) => void = logError,\n): void {\n  invokeClientAsync('captureException', callback, exception);\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param callback A callback that is invoked when the message has been sent.\n */\nexport function captureMessage(\n  message: string,\n  callback: (error?: any) => void = logError,\n): void {\n  invokeClientAsync('captureMessage', callback, message);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @param callback A callback that is invoked when the event has been sent.\n */\nexport function captureEvent(\n  event: SentryEvent,\n  callback: (error?: any) => void = logError,\n): void {\n  invokeClientAsync('captureEvent', callback, event);\n}\n\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n *\n * @param breadcrumb The breadcrumb to record.\n */\nexport function addBreadcrumb(breadcrumb: Breadcrumb): void {\n  invokeClient('addBreadcrumb', breadcrumb);\n}\n\n/**\n * Updates user context information for future events.\n * @param extra User context object to merge into current context.\n */\nexport function setUserContext(user: User): void {\n  invokeClient('setContext', { user });\n}\n\n/**\n * Updates tags context information for future events.\n * @param extra Tags context object to merge into current context.\n */\nexport function setTagsContext(tags: { [key: string]: string }): void {\n  invokeClient('setContext', { tags });\n}\n\n/**\n * Updates extra context information for future events.\n * @param extra Extra context object to merge into current context.\n */\nexport function setExtraContext(extra: object): void {\n  invokeClient('setContext', { extra });\n}\n\n/**\n * Calls a function on the latest client. Use this with caution, it's meant as\n * in \"internal\" helper so we don't need to expose every possible function in\n * the shim. It is not guaranteed that the client actually implements the\n * function.\n *\n * @param method The method to call on the client/frontend.\n * @param args Arguments to pass to the client/fontend.\n */\nexport function _callOnClient(method: string, ...args: any[]): void {\n  invokeClient(method, ...args);\n}\n"]}